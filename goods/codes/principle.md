

    
-   *基本原则：忘记是最好的准绳*
    
    你如果会忘记，那么你要庆幸，因为这是好事。
    
    如果不会对自己的代码生疏，就不会想到有必要让代码容易给别人看懂，就会使与他人的沟通能力受到生疏。
    
    如果会忘记，就有机会给自己添加这样的要求：判定代码质量的准绳，就是离开一月后再阅时，领会它的速度。
    
    因为：
    
    > 开源也只是手段之一，人在机器面前的自由是最重要的。
    > 
    
    ——这也是自由软件运动的内在原则了。
    

----

1.  *可追踪：要避免主动制造混乱*
    
    > 不应通过共享内存传递消息，应通过传递消息共享内存。
    
2.  *面向接口：要用标准统一定义与使用*
    
    任何一个功能定义的开头都要有文档注释，这个文档注释里必须用简单的使用示例来描述这个功能要做到的，然后据此开始编写定义。建议遵循第一条，避免功能有不可追溯的副作用，这样一来你可以轻易就能清晰地描述一个即便很复杂的功能。编写功能定义，在任何一个地方独立地测试功能，使之符合开头对用户许诺的特性，然后使用时就只需要看开头的描述就好了。
    
3.  *充分抽象：要便于灵活地调试排查*
    
    最好可以用功能的子功能的形式，来组织你的众多功能。可以让一个功能只负责根据用户的指定选择调用里面的子功能。这样的功能和子功能最好都是无关运行环境的、单纯的功能，这样就可以单独拿出来检查它的正确性了，随时随地地——这当然也是要在遵循第一条的前提下，才可以做到。
    
4.  *响应式编程：软件的本质是行为到调用的解释器*
    
    只有在一个条件（即需求）下，真正固定不变的部分（——也即是用来锚定了这个需求的所有关键点本身——也即是该需求的物质存在——也即是该需求它本身了），才是**唯一值得写为代码**的。其它一切都要安排为数据：变化不频繁的安排为配置、可以有默认值，可以只有用户需要的时候才去改变它；变化量大的——一般就是业务过程中所有的行为（或者说事件）本身，也就是一切的「突变」、一切用来代表「触发」这一事的发生的，其载体都应当是数据，代码只负责解释这样的数据，「使得某类触发可以怎样时机地发生」，只是解释一串有时序的数据（按照因为需求指定的特定的规则——这也是要写为代码的部分），譬如负责将用户的交互输入行为翻译为机器回应（或者说调用）的用户界面，就应当是一个能把用户行为翻译为具体调用的解释器，这样才对。——其实配置也可以视为不同身份的用户的输入——如不同业务模块运营者身份的用户负责输入不同相关部分的配置、业务用户负责输入响应流。另外，如果需求经常变动，则需要把越来越多的原本构成程序（解释器）逻辑身体的部分，都变为配置（可以用简单的新的数据流程定义来解释配置为该时序数据解释器的本体），从而越发地抽象出一个固定不变的部分。响应式编程的核心就是如此。它能把软件视为解释器、将软件只为软件本身的部分不多不少地抽取出来，并让软件的代码本身就成为一种特定格式的对需求本身的确定的表达，从而优雅地划分出软件本身、及其各个组成部分的界线，同时也合乎上面三点。（[`see`](https://www.cnblogs.com/littleatp/p/11386487.html) [`see`](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)）
    
5.  *真正的入口点：为便于排查而做的工作远比为软件能力而做的工作重要和优雅*
    
    注释当然是一个方面，但只知道这个完全不够。你要注明为什么这样写。注释要能让代码与软件的纲要（如需求）产生联系，而且最好能以接口与接口说明的形式书写——这样基本可以做到只写必要信息的简洁。而这部分内容，将同时成为该模块功能代码的编写指导（功能上需要合乎接口规定——即使用的方式与效果）和对该模块功能使用时的唯一参考。——此，即是人，在进入作为工具而言的程序世界时的入口。
    
6.  *...：...*
    
    ...
 
